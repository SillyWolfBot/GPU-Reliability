<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Physics-Informed GPU Aging Model</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Typography & layout styling -->
  <style>
    :root {
      --bg-color: #f4f4f7;
      --paper-color: #ffffff;
      --accent-color: #3742fa;
      --accent-soft: #e1e5ff;
      --text-color: #222222;
      --muted-color: #777777;
      --border-color: #e0e0ea;
      --code-bg: #f5f5fb;
      --shadow-soft: 0 18px 45px rgba(15, 23, 42, 0.12);
      --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", Roboto, sans-serif;
      --font-serif: "Georgia", "Cambria", "Times New Roman", serif;
      --max-width: 980px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top, #eef1ff 0, var(--bg-color) 55%);
      font-family: var(--font-sans);
      color: var(--text-color);
      -webkit-font-smoothing: antialiased;
      line-height: 1.6;
    }

    .page-shell {
      min-height: 100vh;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 32px 16px 40px;
    }

    .paper {
      background: var(--paper-color);
      max-width: var(--max-width);
      width: 100%;
      border-radius: 18px;
      box-shadow: var(--shadow-soft);
      padding: 32px 26px 32px;
      position: relative;
    }

    @media (min-width: 900px) {
      .paper {
        padding: 40px 56px 40px;
      }
    }

    /* Header */

    .paper-header {
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 20px;
      margin-bottom: 20px;
    }

    .paper-title {
      font-family: var(--font-serif);
      font-size: clamp(1.9rem, 2.4vw + 1.2rem, 2.6rem);
      line-height: 1.15;
      margin: 0 0 8px;
      letter-spacing: 0.01em;
    }

    .paper-subtitle {
      margin: 0;
      font-size: 0.98rem;
      color: var(--muted-color);
    }

    .paper-meta {
      margin-top: 14px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px 18px;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted-color);
    }

    .meta-pill {
      padding: 3px 11px;
      border-radius: 999px;
      background: #f5f6ff;
      border: 1px solid #dfe3ff;
      color: #475569;
      font-weight: 500;
    }

    /* Tab navigation */

    .tab-nav {
      margin: 4px 0 18px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .tab-button {
      position: relative;
      border: none;
      background: transparent;
      padding: 10px 14px;
      margin: 0 4px -1px 0;
      font-size: 0.86rem;
      font-weight: 500;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: #6b7280;
      cursor: pointer;
      transition:
        color 0.16s ease,
        background 0.16s ease;
    }

    .tab-button::after {
      content: "";
      position: absolute;
      left: 12px;
      right: 12px;
      bottom: -1px;
      height: 2px;
      border-radius: 999px;
      background: transparent;
      transition: background 0.18s ease;
    }

    .tab-button:hover {
      color: #111827;
      background: #f8f8ff;
    }

    .tab-button.active {
      color: #111827;
      background: #f9f9ff;
    }

    .tab-button.active::after {
      background: var(--accent-color);
    }

    /* Main content */

    .paper-body {
      margin-top: 8px;
    }

    .paper-section {
      padding: 16px 0 12px;
      scroll-margin-top: 120px;
    }

    .section-label {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--muted-color);
      margin-bottom: 4px;
    }

    .paper-section h2 {
      font-family: var(--font-serif);
      font-size: 1.45rem;
      margin: 0 0 10px;
      line-height: 1.25;
    }

    .paper-section h3 {
      font-family: var(--font-serif);
      font-size: 1.12rem;
      margin: 26px 0 6px;
    }

    p {
      margin: 5px 0 12px;
      font-size: 0.98rem;
    }

    ul {
      margin: 4px 0 14px 1.1rem;
      padding-left: 0.8rem;
    }

    li {
      margin-bottom: 4px;
      font-size: 0.96rem;
    }

    strong {
      font-weight: 600;
    }

    em {
      font-style: italic;
    }

    /* Equation styling */

    .equation {
      font-family: "Latin Modern Math", "Cambria Math", "STIX Two Math",
        var(--font-serif);
      font-size: 0.98rem;
      background: var(--code-bg);
      border-radius: 8px;
      padding: 8px 14px;
      margin: 10px 0 14px;
      overflow-x: auto;
    }

    .equation-inline {
      font-family: "Latin Modern Math", "Cambria Math", "STIX Two Math",
        var(--font-serif);
    }

    /* Callout-style explanations */

    .callout {
      border-left: 3px solid var(--accent-color);
      background: #f7f8ff;
      padding: 8px 14px 10px;
      margin: 8px 0 16px;
      border-radius: 10px;
      font-size: 0.94rem;
      color: #374151;
    }

    .callout-title {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: #6b7280;
      margin-bottom: 2px;
      font-weight: 600;
    }

    /* Footer */

    .paper-footer {
      border-top: 1px solid var(--border-color);
      margin-top: 24px;
      padding-top: 12px;
      font-size: 0.78rem;
      color: var(--muted-color);
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 6px;
    }

    .mono {
      font-family: "JetBrains Mono", "SF Mono", Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 0.85em;
    }

    @media (max-width: 640px) {
      .paper {
        border-radius: 14px;
        padding: 22px 16px 26px;
      }

      .paper-section h2 {
        font-size: 1.3rem;
      }

      .paper-section h3 {
        font-size: 1.05rem;
      }
    }
  </style>

  <!-- MathJax for equations -->
  <script
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>

<body>
  <div class="page-shell">
    <article class="paper" aria-label="Physics-informed GPU aging model">
      <header class="paper-header">
        <h1 class="paper-title">
          Physics-Informed Modeling of GPU Aging from Microscopic NBTI to Macroscopic Sensor Dynamics
        </h1>
        <p class="paper-subtitle">
          A unified framework that fuses semiconductor-level reaction–diffusion aging physics with
          nonlinear sensor dynamics via a physics-informed LSTM.
        </p>
        <div class="paper-meta">
          <span class="meta-pill">Physics-Informed Learning</span>
          <span class="meta-pill">GPU Reliability</span>
          <span class="meta-pill">NBTI &amp; Reaction–Diffusion</span>
          <span class="meta-pill">MdRQA</span>
          <span class="meta-pill">LSTM</span>
        </div>
      </header>

      <!-- Tab navigation (scrolls to sections) -->
      <nav class="tab-nav" aria-label="Section navigation">
        <button class="tab-button active" data-target="abstract">
          Abstract
        </button>
        <button class="tab-button" data-target="microscopic">
          Microscopic Aging
        </button>
        <button class="tab-button" data-target="macroscopic">
          Macroscopic Dynamics
        </button>
        <button class="tab-button" data-target="fusion">
          Physics-Informed Fusion
        </button>
        <button class="tab-button" data-target="outputs">
          Outputs &amp; Interpretation
        </button>
        <button class="tab-button" data-target="online">
          Online Operation
        </button>
      </nav>

      <main class="paper-body">
        <!-- ABSTRACT / HIGH-LEVEL INTUITION -->
        <section id="abstract" class="paper-section">
          <div class="section-label">Section 0</div>
          <h2>High-Level Intuition (Abstract / Mental Model)</h2>

          <p>
            We describe GPU aging by stitching together two views of reality into a single model.
            At the <strong>microscopic level</strong>, we simulate how PMOS transistors slowly wear
            out under stress using a reaction–diffusion model of NBTI, which produces a
            time-varying threshold-voltage shift
            <span class="equation-inline">\(\Delta V_{th}(t)\)</span>.
            This is the physics view of how the silicon <em>should</em> age given voltage,
            temperature, and activity.
          </p>

          <p>
            At the <strong>macroscopic level</strong>, we observe what the GPU is actually doing
            through sensors: temperature, currents, voltages, utilization, and electromagnetic
            activity. From these we extract nonlinear dynamical features (MdRQA) that tell us
            whether the system is in stable, repetitive regimes or wandering into chaotic,
            potentially damaging behavior.
          </p>

          <p>
            A <strong>physics-informed LSTM</strong> then fuses these two layers: it sees both the
            physics-based \(\Delta V_{th}\) trajectories (from reaction–diffusion) and the real
            sensor-derived features (including MdRQA). It is trained so that its predictions are
            consistent with both the measured sensor data <em>and</em> the underlying aging
            physics. The outputs are three things: an estimated
            \(\Delta V_{th}(t)\) (a proxy for microscopic damage), a normalized “operational age”
            \(A(t)\) in \([0, 1]\), and a remaining useful life (RUL) estimate in the same time
            units as the input timeline. The model runs continuously, updating these quantities as
            new sensor data arrive.
          </p>
        </section>

        <!-- 1. MICROSCOPIC AGING -->
        <section id="microscopic" class="paper-section">
          <div class="section-label">Section 1</div>
          <h2>Microscopic NBTI Aging via Reaction–Diffusion</h2>

          <p>
            At the transistor level, we model degradation dominated by
            <strong>negative bias temperature instability (NBTI)</strong> in PMOS devices.
            Long-term electrical and thermal stress generates interface traps and shifts the
            threshold voltage \(V_{th}\) upward. The incremental shift
          </p>

          <p class="equation">
            \[
            \Delta V_{th}(t) = V_{th}(t) - V_{th,0}
            \]
          </p>

          <p>
            acts as a microscopic measure of accumulated damage.
          </p>

          <p>
            We adopt a <strong>reaction–diffusion (R–D)</strong> description that captures:
          </p>

          <ul>
            <li>
              <strong>Stress phase</strong>: trap generation when the device is under negative gate
              bias \((V_{gs} = -V_{dd})\).
            </li>
            <li>
              <strong>Recovery phase</strong>: partial annealing when the device is unbiased
              \((V_{gs} = 0)\).
            </li>
          </ul>

          <p>
            During stress, the threshold voltage follows
          </p>

          <p class="equation">
            \[
            V_{th,\text{stress}}(t)
            = \big(K_v\, t_{\text{stress}}^{1/2} + 2n V_{th,0}\big)^{2n}
            \]
          </p>

          <p>where:</p>

          <ul>
            <li>\(K_v\) encodes dependence on electric field, supply voltage \(V_{dd}\), and temperature \(T\),</li>
            <li>\(n\) is a time exponent (typically \(n \approx 1/6\)),</li>
            <li>\(t_{\text{stress}}\) is the cumulative time under stress,</li>
            <li>\(V_{th,0}\) is the initial threshold voltage.</li>
          </ul>

          <div class="callout">
            <div class="callout-title">Intuition</div>
            <p>
              The longer and harder you stress the device, the more traps form and the larger
              \(V_{th}\) becomes, following a sublinear power law in time.
            </p>
          </div>

          <p>
            During recovery \((V_{gs} = 0)\), as traps partially anneal, we use
          </p>

          <p class="equation">
            \[
            V_{th,\text{recov}}(t)
            = V_{th,\text{stress}}
            \left(
              1 - 2\xi_1 t_e +
              \frac{\xi_2 C t_{\text{recov}}}{(1+\delta)t_{ox} + \sqrt{Ct}}
            \right)
            \]
          </p>

          <p>with:</p>

          <ul>
            <li>\(\xi_1, \xi_2, \delta\): material- and process-dependent constants,</li>
            <li>\(t_{ox}\): oxide thickness,</li>
            <li>\(t_e\): effective oxide thickness,</li>
            <li>\(t_{\text{recov}}\): cumulative time in recovery,</li>
            <li>\(C\): diffusion-related constant.</li>
          </ul>

          <p>
            This expression captures the fact that some of the NBTI damage relaxes over time, but
            not fully.
          </p>

          <p>
            Over many stress–recovery cycles, we iterate:
          </p>

          <p class="equation">
            \[
            V_{th,i}^{\text{stress}}
            = \Big( K_v (\alpha T_{clk})^{2n} + V_{th,i-1}^{\text{recov}} \Big)^{2n},
            \]
          </p>

          <p class="equation">
            \[
            V_{th,i}^{\text{recov}}
            = V_{th,i}^{\text{stress}}
            \left(
              1 - 2\xi_1 t_e +
              \frac{\xi_2 C (1-\alpha)T_{clk}}{(1+\delta)t_{ox} + \sqrt{C_i T_{clk}}}
            \right)
            \]
          </p>

          <p>where:</p>

          <ul>
            <li>\(i\) indexes cycles,</li>
            <li>\(T_{clk}\) is the clock period (or a chosen stress-update interval),</li>
            <li>\(\alpha\) is the <strong>duty cycle</strong> (fraction of time under stress).</li>
          </ul>

          <p>
            So if we know \(\alpha\), \(V_{dd}\), \(T\), and process parameters, we can generate a
            <strong>microscopic \(\Delta V_{th}(t)\) curve</strong> that represents the idealized
            aging trajectory of the transistor ensemble.
          </p>

          <h3>From Hidden Transistor Stress to Effective Duty Cycle</h3>

          <p>
            In a real GPU, we do <strong>not</strong> see individual gate biases. Instead, we
            observe:
          </p>

          <ul>
            <li>board-level voltages \(V_{dd}(t)\) and currents \(I(t)\),</li>
            <li>temperature sensors \(T(t)\),</li>
            <li>utilization metrics \(U(t)\),</li>
            <li>electromagnetic activity \(E(t)\) or similar.</li>
          </ul>

          <p>
            We use those as <strong>proxies</strong> to construct an effective stress-intensity
            function:
          </p>

          <p class="equation">
            \[
            \sigma(t) = f(V_{dd}(t)) \, g(T(t)) \, h(U(t))
            \]
          </p>

          <p>
            where each of \(f, g, h\) is a calibrated acceleration factor (e.g., Arrhenius-like in
            \(T\), power-law in \(V\), linear or saturating in activity).
          </p>

          <p>
            From \(\sigma(t)\), we define an effective duty cycle over a window of length \(T\):
          </p>

          <p class="equation">
            \[
            \alpha_{\text{eff}} = \frac{1}{T} \int_0^T \sigma(t)\, dt.
            \]
          </p>

          <p>
            We feed \(\alpha_{\text{eff}}\), along with \(V_{dd}(t)\) and \(T(t)\), into the R–D
            model to generate <strong>simulated \(\Delta V_{th}\) trajectories</strong>:
          </p>

          <p class="equation">
            \[
            \Delta V_{th}^{\text{phys}}(t)
            \]
          </p>

          <p>
            These are our <strong>physics-based prior</strong> on how the silicon should age given
            the measured stress conditions.
          </p>
        </section>

        <!-- 2. MACROSCOPIC DYNAMICS -->
        <section id="macroscopic" class="paper-section">
          <div class="section-label">Section 2</div>
          <h2>Macroscopic Dynamics via MdRQA</h2>

          <p>
            Real GPUs live in a messy world: cooling control loops, workload bursts, fan
            hysteresis, and power delivery noise make behavior deviate from the neat R–D
            trajectory. To quantify this messy, emergent behavior, we apply
            <strong>multidimensional recurrence quantification analysis (MdRQA)</strong> on the
            multivariate sensor stream.
          </p>

          <p>
            We collect the relevant signals into a vector
          </p>

          <p class="equation">
            \[
            X(t) = [T(t), I(t), V(t), E(t), U(t)] \in \mathbb{R}^d
            \]
          </p>

          <p>
            (where the exact components can be extended as needed). Over a window, we view this as
            a trajectory in a reconstructed phase space, and build the
            <strong>recurrence matrix</strong>:
          </p>

          <p class="equation">
            \[
            R_{ij} = \Theta(\varepsilon - \| X_i - X_j \|),
            \]
          </p>

          <p>where:</p>

          <ul>
            <li>\(X_i = X(t_i)\),</li>
            <li>\(\|\cdot\|\) is Euclidean distance (or another norm),</li>
            <li>\(\varepsilon\) is a neighborhood radius,</li>
            <li>\(\Theta\) is the Heaviside step function (1 if inside the neighborhood, 0 otherwise).</li>
          </ul>

          <p>
            From \(R_{ij}\), we compute standard MdRQA scalars:
          </p>

          <ul>
            <li>
              <strong>RR</strong> (recurrence rate): fraction of recurrent points; how often the
              system revisits previous states.
            </li>
            <li>
              <strong>DET</strong> (determinism): fraction of recurrence points forming diagonal
              lines; measures predictability or periodicity.
            </li>
            <li>
              <strong>LAM</strong> (laminarity): captures “sticking” behavior in particular states.
            </li>
            <li>
              <strong>ENTR</strong> (entropy of diagonal line lengths): complexity of the temporal
              patterns.
            </li>
            <li>
              <strong>TT</strong> (trapping time): average duration of laminar episodes.
            </li>
          </ul>

          <h3>Interpretation of MdRQA Features</h3>

          <p>
            Interpretation:
          </p>

          <ul>
            <li>
              High DET, low ENTR &rarr; stable, repetitive operating conditions (e.g., steady HPC
              workloads, well-behaved cooling).
            </li>
            <li>
              Dropping DET, rising ENTR &rarr; transitions, regime shifts, or emerging instability
              (e.g., thermal runaways, throttling, erratic power cycling).
            </li>
          </ul>

          <p>
            These MdRQA descriptors compress the <strong>macroscopic temporal structure</strong> of
            the system into a feature vector:
          </p>

          <p class="equation">
            \[
            Z(t) = [\text{RR}(t), \text{DET}(t), \text{LAM}(t), \text{ENTR}(t), \text{TT}(t), \dots]
            \]
          </p>

          <p>
            over sliding windows.
          </p>
        </section>

        <!-- 3. PHYSICS-INFORMED LSTM FUSION -->
        <section id="fusion" class="paper-section">
          <div class="section-label">Section 3</div>
          <h2>Physics-Informed LSTM Fusion</h2>

          <p>
            The <strong>fusion layer</strong> is a physics-informed LSTM that takes both:
          </p>

          <ol>
            <li>
              The <strong>physics-based microscopic aging trajectory</strong>
              \(\Delta V_{th}^{\text{phys}}(t)\) from the R–D model, and
            </li>
            <li>
              The <strong>macroscopic feature streams</strong> from sensors (MdRQA features \(Z(t)\)
              plus simpler statistics such as means, variances, gradients of \(T\), \(V\), \(I\),
              etc.).
            </li>
          </ol>

          <p>
            Let’s define, at each time step \(t\), a combined input feature vector:
          </p>

          <p class="equation">
            \[
            x_t = \big[ Z(t), \text{stats}(X(t)), \Delta V_{th}^{\text{phys}}(t) \big]
            \in \mathbb{R}^p.
            \]
          </p>

          <p>
            The LSTM processes sequences \((x_{t-L+1}, \dots, x_t)\) of length \(L\) and produces
            outputs \(y_t\). Its internal recurrence is:
          </p>

          <p class="equation">
            \[
            (h_t, c_t) = \text{LSTM}(x_t, h_{t-1}, c_{t-1}),
            \]
          </p>

          <p class="equation">
            \[
            y_t = W_o h_t + b_o,
            \]
          </p>

          <p>where:</p>

          <ul>
            <li>\(h_t\) is the hidden state,</li>
            <li>\(c_t\) is the cell state (long-term memory),</li>
            <li>\(W_o, b_o\) are output layer parameters,</li>
            <li>\(y_t \in \mathbb{R}^m\) is the output vector at time \(t\).</li>
          </ul>

          <h3>Physics-Informed Loss</h3>

          <p>
            Training uses a <strong>composite loss</strong>:
          </p>

          <p class="equation">
            \[
            \mathcal{L}_{\text{total}}
            = \mathcal{L}_{\text{data}} + \lambda \mathcal{L}_{\text{physics}}.
            \]
          </p>

          <ul>
            <li>
              \(\mathcal{L}_{\text{data}}\) is the data misfit: e.g., MSE between predicted and
              observed health indicators (from accelerated tests, periodic benchmarks, or known
              failure points).
            </li>
            <li>
              \(\mathcal{L}_{\text{physics}}\) penalizes deviations from the R–D model. A simple
              form is:
            </li>
          </ul>

          <p class="equation">
            \[
            \mathcal{L}_{\text{physics}}
            = \frac{1}{N} \sum_t
            \big\| \widehat{\Delta V_{th}}(t)
            - \Delta V_{th}^{\text{phys}}(t) \big\|^2,
            \]
          </p>

          <p>
            where \(\widehat{\Delta V_{th}}(t)\) is the LSTM’s predicted \(\Delta V_{th}\) component.
          </p>

          <p>
            \(\lambda\) is a tunable coefficient (selected via Bayesian optimization) that
            balances <strong>data fit</strong> (match reality) versus
            <strong>physics adherence</strong> (respect NBTI kinetics).
          </p>

          <div class="callout">
            <div class="callout-title">Effect of the Physics Term</div>
            <p>
              The R–D model provides a <strong>prior trajectory</strong> for how aging “should”
              evolve. The LSTM uses sensor dynamics (via MdRQA and statistics) to learn systematic
              deviations from that prior under real workloads and environmental conditions. The
              physics term in the loss keeps the learned mapping from drifting into unphysical
              nonsense.
            </p>
          </div>
        </section>

        <!-- 4. OUTPUTS & INTERPRETATION -->
        <section id="outputs" class="paper-section">
          <div class="section-label">Section 4</div>
          <h2>Outputs and Their Interpretation (Engineering View)</h2>

          <p>
            The model’s prediction is explicitly <strong>multidimensional</strong>. At each time
            \(t\), it outputs a health vector:
          </p>

          <p class="equation">
            \[
            y_t = \big[
            \widehat{\Delta V_{th}}(t), \;
            \widehat{A}(t), \;
            \widehat{\text{RUL}}(t) \big]
            \in \mathbb{R}^3.
            \]
          </p>

          <p>
            Optionally, there may be a fourth head for discrete health classes, but let’s pin down
            the core three:
          </p>

          <ol>
            <li>
              <strong>Estimated threshold-voltage shift</strong><br>
              <p class="equation">
                \[
                \widehat{\Delta V_{th}}(t)
                \]
              </p>
              <ul>
                <li>Units: volts.</li>
                <li>
                  Interpretation: model’s best estimate of how far the effective \(V_{th}\) of the
                  critical path devices has drifted from its fresh value.
                </li>
                <li>
                  This is a <strong>physics-aligned proxy</strong> for microscopic damage and ties
                  directly back to timing margin.
                </li>
              </ul>
            </li>

            <li>
              <strong>Operational age index</strong><br>
              <p>
                We define a critical threshold shift \(\Delta V_{th,\text{crit}}\) corresponding to
                end-of-life (e.g., when timing violations exceed a specified rate). The age index is:
              </p>

              <p class="equation">
                \[
                \widehat{A}(t)
                = \frac{\widehat{\Delta V_{th}}(t)}{\Delta V_{th,\text{crit}}}.
                \]
              </p>

              <ul>
                <li>Dimensionless fraction, ideally clipped to \([0, 1.2]\) or similar.</li>
                <li>\(\widehat{A}(t) \approx 0\): nearly fresh.</li>
                <li>\(\widehat{A}(t) = 1\): nominal end-of-life boundary.</li>
                <li>\(\widehat{A}(t) &gt; 1\): device is operating beyond the modeled safe aging envelope.</li>
              </ul>
            </li>

            <li>
              <strong>Remaining Useful Life (RUL)</strong><br>
              <p class="equation">
                \[
                \widehat{\text{RUL}}(t)
                \]
              </p>

              <ul>
                <li>
                  Units: <strong>same time units as the model’s time base</strong>, e.g., hours of
                  operation or equivalent stress hours.
                </li>
                <li>
                  Definition: predicted time until \(\widehat{A}(t)\) reaches 1 under
                  <strong>learned typical future stress patterns</strong> (i.e., given how this
                  device has historically been used).
                </li>
                <li>
                  In practice, the LSTM learns a mapping from the current latent state \(h_t\) and
                  recent trajectory to a scalar horizon until failure.
                </li>
              </ul>
            </li>
          </ol>

          <p>
            Concretely, you can view the network as implementing a function
          </p>

          <p class="equation">
            \[
            F_\theta : \mathbb{R}^{L \times p} \rightarrow \mathbb{R}^3,
            \]
          </p>

          <p>
            such that
          </p>

          <p class="equation">
            \[
            y_t = F_\theta(x_{t-L+1:t}) =
            \big(
              \widehat{\Delta V_{th}}(t),
              \widehat{A}(t),
              \widehat{\text{RUL}}(t)
            \big).
            \]
          </p>

          <p>
            So if you “compile and run” this model in software, for each time \(t\) you feed it
            the last \(L\) timesteps of features and it returns this triplet.
          </p>

          <p>
            Optionally, we can add a <strong>classification head</strong>:
          </p>

          <p class="equation">
            \[
            \widehat{s}(t) = \text{softmax}(W_s h_t + b_s) \in \mathbb{R}^K
            \]
          </p>

          <p>
            where \(K\) is the number of discrete health states (e.g., {healthy, warning,
            critical}). This doesn’t change the continuous outputs; it just adds an easily
            consumable label.
          </p>
        </section>

        <!-- 5. ONLINE OPERATION -->
        <section id="online" class="paper-section">
          <div class="section-label">Section 5</div>
          <h2>Deployment and Operational expectations</h2>

          <p>
            In deployment, the framework operates as a streaming system with a fixed update period
            \(\Delta t\) (e.g., once per second, once per minute):
          </p>

          <ol>
            <li>
              <strong>Sensor ingestion</strong><br>
              At each time \(t\):
              <ul>
                <li>Read raw sensors \(X(t) = [T, I, V, E, U, \dots]\).</li>
              </ul>
            </li>

            <li>
              <strong>Feature construction</strong> (over a sliding window of length \(L \cdot \Delta t\)):<br>
              <ul>
                <li>
                  Compute statistical summaries (means, variances, derivatives) of \(X\) over the
                  window.
                </li>
                <li>
                  Run MdRQA over the same window to obtain \(Z(t)\).
                </li>
                <li>
                  Use the windowed stress surrogate \(\sigma(t')\) to update
                  \(\alpha_{\text{eff}}\) and propagate the R–D model, obtaining
                  \(\Delta V_{th}^{\text{phys}}(t)\).
                </li>
              </ul>
            </li>

            <li>
              <strong>LSTM inference</strong><br>
              <ul>
                <li>
                  Form \(x_t = [Z(t), \text{stats}(X(t)), \Delta V_{th}^{\text{phys}}(t)]\).
                </li>
                <li>
                  Feed \(x_t\) and the previous states \((h_{t-1}, c_{t-1})\) into the LSTM.
                </li>
                <li>
                  Get updated states \((h_t, c_t)\) and the output vector \(y_t\).
                </li>
              </ul>
            </li>

            <li>
              <strong>Health outputs</strong><br>
              <ul>
                <li>
                  Extract \(\widehat{\Delta V_{th}}(t)\), \(\widehat{A}(t)\), and
                  \(\widehat{\text{RUL}}(t)\) from \(y_t\).
                </li>
                <li>
                  Optionally, map \(\widehat{A}(t)\) and \(\widehat{\text{RUL}}(t)\) to health
                  flags (e.g., “normal”, “de-rate”, “retire”).
                </li>
              </ul>
            </li>
          </ol>

          <p>
            So “continuous update of operational age” is not poetry; it literally means:
          </p>

          <ul>
            <li>Maintain the LSTM hidden state across calls.</li>
            <li>
              At each sensor update, recompute features, advance the physics-based
              \(\Delta V_{th}\), perform a forward pass, and overwrite
              \(\widehat{A}(t)\) and \(\widehat{\text{RUL}}(t)\).
            </li>
          </ul>

          <p>
            Those two scalars, plus \(\widehat{\Delta V_{th}}(t)\), are the
            <strong>machine-readable contract</strong> of the model: they are exactly what
            downstream scheduling, cooling, or maintenance logic will consume.
          </p>
        </section>
      </main>

      <footer class="paper-footer">
        <span>Physics-informed GPU aging model conceptual specification by Muneeb Rasool</span>
        <span class="mono">Tensor Machines, Inc</span>
      </footer>
    </article>
  </div>

  <!-- Tab behavior: smooth scroll & active-state sync -->
  <script>
    (function () {
      const buttons = Array.from(document.querySelectorAll(".tab-button"));
      const sections = Array.from(document.querySelectorAll(".paper-section"));

      function setActiveButton(targetId) {
        buttons.forEach((btn) => {
          const isActive = btn.getAttribute("data-target") === targetId;
          btn.classList.toggle("active", isActive);
        });
      }

      function scrollToSection(targetId) {
        const section = document.getElementById(targetId);
        if (!section) return;
        section.scrollIntoView({ behavior: "smooth", block: "start" });
      }

      // Click behavior
      buttons.forEach((btn) => {
        btn.addEventListener("click", (e) => {
          e.preventDefault();
          const targetId = btn.getAttribute("data-target");
          setActiveButton(targetId);
          scrollToSection(targetId);

          if (history.replaceState) {
            history.replaceState(null, "", "#" + targetId);
          } else {
            window.location.hash = targetId;
          }
        });
      });

      // IntersectionObserver to sync tab highlight with scroll
      const observerOptions = {
        root: null,
        rootMargin: "0px 0px -60% 0px",
        threshold: 0.3,
      };

      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const id = entry.target.id;
            setActiveButton(id);
          }
        });
      }, observerOptions);

      sections.forEach((section) => observer.observe(section));

      // On load, jump to hash if present
      window.addEventListener("load", () => {
        const hash = window.location.hash.replace("#", "");
        if (hash) {
          const section = document.getElementById(hash);
          if (section) {
            section.scrollIntoView({ behavior: "auto", block: "start" });
            setActiveButton(hash);
          }
        }
      });
    })();
  </script>
</body>
</html>
